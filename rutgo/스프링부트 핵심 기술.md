# IoC 컨테이너와 빈

## 스프링 IoC 컨테이너와 빈

- Inversion of Control: 의존 관계 주입(Dependency Injection)이라고도 하며, 어떤 객체가
사용하는 의존 객체를 직접 만들어 사용하는게 아니라, 주입 받아 사용하는 방법을 말 함.

### 예제코드

```java
package inflearn.core.ioc;

public class Book {
	private final Long id;
	private final String title;

	public Book(final Long id, final String title) {
		this.id = id;
		this.title = title;
	}

	public Long getId() {
		return id;
	}
}
```

```java
 package inflearn.core.ioc;

import org.springframework.stereotype.Repository;

@Repository
public class BookRepository {
	public Book save(Book book) {
		return book;
	}
}
```

```java
package inflearn.core.ioc;

import org.springframework.stereotype.Service;

@Service
public class BookService {
	private final BookRepository bookRepository;

	public BookService(final BookRepository bookRepository) {
		this.bookRepository = bookRepository;
	}

	public void createBook() {
		System.out.println("북을 생성합니다.");
	}
}
```

```java
package inflearn.core.ioc;

import org.springframework.stereotype.Service;

@Service
public class BookService {
	private final BookRepository bookRepository;

	public BookService(final BookRepository bookRepository) {
		this.bookRepository = bookRepository;
	}

	public Book createBook(Book book) {
		return bookRepository.save(book);
	}
}
```

- IoC를 이용하지 않았을 경우

```java
package inflearn.core.ioc;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;

@ExtendWith(SpringExtension.class)
@SpringBootTest
class BookServiceTest {
	@Test
	void test() {
		BookRepository bookRepository = new BookRepository();
		BookService bookService = new BookService(bookRepository);
		bookService.createBook(new Book(1L, "hello"));
	}
}
```

- IoC를 이용했을 경우

```java
package inflearn.core.ioc;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;

@ExtendWith(SpringExtension.class)
@SpringBootTest
class BookServiceTest {

	@Autowired
	private BookService bookService;

	@Test
	void test2() {
		bookService.createBook(new Book(1L, "hello"));
	}
}
```

### 스프링 IoC 컨테이너

- [BeanFactory](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html)
    - 최상위 인터페이스로 가장 핵심적인 것이다.
- 애플리케이션 컴포넌트의 중앙 저장소.
- 빈 설정 소스로 부터 빈 정의를 읽어들이고, 빈을 구성하고 제공한다.
- 처음에 IoC를 xml 설정으로 정의했지만, 현재는 DI를 통해 구현되어 있다.

### 빈

- 스프링 IoC 컨테이너가 관리 하는 객체.
- `@Component`가 붙어 있으면, 모두 빈이 된다.(`@SpringBootApplication`이 붙어있는 하위 패키지)

- 장점
    - 의존성 관리
    - 스코프
        - 싱글톤: 하나
            - 이렇게 사용하는 이유는 성능 비용을 내리기 위해서다.
        - 프로포토타입: 매번 다른 객체
    - 라이프사이클 인터페이스 지원
        - bean 생성 후 추가적인 작업을 하고 싶을때 사용

        ```java
        package inflearn.core.ioc;

        import javax.annotation.PostConstruct;

        import org.springframework.stereotype.Service;

        @Service
        public class BookService {
        	private final BookRepository bookRepository;

        	@PostConstruct
        	public void init(){
        		System.out.println("빈 생성 이후 실행됩니다.");
        	}
        }
        ```

    - 스프링 자체에서 이걸 이용해서 많은 기능을 제공한다.(예를 들면 AOP 적용이 있다.)

### 문제점

- 의존성이 있다보니 하나의 클래스의 단위 테스트가 힘들어 진다.
- 예를들면 Service가 Repository를 쓰는 기능을 테스트 한다면 Repository 내부가 제대로 구현되어 잇지 않다면 테스트를 하기 힘들것 이다.
- 이걸 해결하기 위해 나온 것이 `@Mock` 이다.(가짜 객체라고 생각하면 된다.)

```java
package inflearn.core.ioc;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;

@ExtendWith(SpringExtension.class)
@SpringBootTest
class BookServiceTest {

	@Autowired
	private BookService bookService;

	@Mock
	private BookRepository bookRepository;

	@Test
	void test3() {
		Book book = new Book(1L, "hello");
		when(bookRepository.save(book)).thenReturn(book);
		assertThat(bookService.createBook(book).getId()).isEqualTo(book.getId());
	}
}
```

### [ApplicationContext](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html)

- BeanFactory
- 메시지 소스 처리 기능 (i18n) : MessageSource
- ApplicationEventPublisher: 이벤트 발행
- ResoruceLoader : 리소스 로딩 기능
- HierarchicalBeanFactory
- ListableBeanFactory
- EnviromentCapable
- ResourcePatternResolver

## ApplicationContext와 다양한 빈 설정 방법

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4750f32b-7cbd-4a5d-9626-2e40e285d4b2/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4750f32b-7cbd-4a5d-9626-2e40e285d4b2/Untitled.png)

### 스프링 IoC 컨테이너의 역할

- 빈 인스턴스 생성
- 의존 관계 설정
- 빈 제공

### AppcliationContext

- ClassPathXmlApplicationContext (XML)
- AnnotationConfigApplicationContext (Java)

### 빈 설정

- 빈 명세서
- 빈에 대한 정의를 담고 있다.
    - 이름
    - 클래스
    - 스코프
    - 생성자 아규먼트 (constructor)
    - 프로퍼트 (setter)
    - ..

### 컴포넌트 스캔

- 설정 방법
    - XML 설정에서는 context:component-scan
    - 자바 설정에서 @ComponentScan
- 특정 패키지 이하의 모든 클래스 중에 @Component 애노테이션을 사용한 클래스를
빈으로 자동으로 등록 해 줌.

## @Autowire

- 필요한 의존 객체의 “타입"에 해당하는 빈을 찾아 주입한다.

### @Autowired

- required: 기본값은 true (따라서 못 찾으면 애플리케이션 구동 실패)
- 사용할 수 있는 위치
    - 생성자 (스프링 4.3 부터는 생략 가능)
    - 세터
    - 필드
- 경우의 수
- 해당 타입의 빈이 없는 경우
- 해당 타입의 빈이 한 개인 경우
- 해당 타입의 빈이 여러 개인 경우
    - 빈 이름으로 시도,
    - 같은 이름의 빈 찾으면 해당 빈 사용
    - 같은 이름 못 찾으면 실패
- 같은 타입의 빈이 여러개 일 때
    - @Primary
    - 해당 타입의 빈 모두 주입 받기
    - @Qualifier (빈 이름으로 주입)
- 동작 원리
    - 첫시간에 잠깐 언급했던 빈 라이프사이클 기억하세요?
    - [BeanPostProcessor](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html)
        - 새로 만든 빈 인스턴스를 수정할 수 있는 라이프 사이클 인터페이스
    - [AutowiredAnnotationBeanPostProcessor](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html) extends BeanPostProcessor
        - 스프링이 제공하는 @Autowired와 @Value 애노테이션 그리고 JSR-330의
        @Inject 애노테이션을 지원하는 애노테이션 처리기.

## @Component와 컴포넌트 스캔

### 컨포넌트 스캔 주요 기능

- 스캔 위치 설정
- 필터: 어떤 애노테이션을 스캔 할지 또는 하지 않을지

### @Component

- @Repository
- @Service
- @Controller
- @Configuration

### 동작 원리

- @ComponentScan은 스캔할 패키지와 애노테이션에 대한 정보
- 실제 스캐닝은 ConfigurationClassPostProcessor라는 BeanFactoryPostProcessor에
의해 처리 됨.

### 펑션을 사용한 빈 등록

```java
public static void main(String[] args) {
	new SpringApplicationBuilder()
	.sources(Demospring51Application.class)
	.initializers((ApplicationContextInitializer<GenericApplicationContext>)
	applicationContext -> {
		applicationContext.registerBean(MyBean.class);
	})
	.run(args);
}
```

## 빈의 스코프

### 스코프

- 싱글톤
- 프로토타입
    - Request
    - Session
    - WebSocket
    - ...
- 프로토타입 빈이 싱글톤 빈을 참조하면?
    - 아무 문제 없음.
- 싱글톤 빈이 프로토타입 빈을 참조하면?
    - 프로토타입 빈이 업데이트가 안되네?
    - 업데이트 하려면
        - scoped-proxy
        - Object-Provider
        - Provider (표준)

### [프록시](https://en.wikipedia.org/wiki/Proxy_pattern)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33c14cb2-d616-440d-a462-b848787dab50/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33c14cb2-d616-440d-a462-b848787dab50/Untitled.png)

- 싱글톤 객체 사용시 주의할 점
- 프로퍼티가 공유.
- ApplicationContext 초기 구동시 인스턴스 생성.

## Environment 1부. 프로파일

- 프로파일과 프로퍼티를 다루는 인터페이스.
- ApplicationContext extends [EnvironmentCapable](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/EnvironmentCapable.html)
    - getEnvironment()

### 프로파일

- 빈들의 그룹
- [Environment](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/Environment.html)의 역할은 활성화할 프로파일 확인 및 설정

### 프로파일 유즈케이스

- 테스트 환경에서는 A라는 빈을 사용하고, 배포 환경에서는 B라는 빈을 쓰고 싶다.
- 이 빈은 모니터링 용도니까 테스트할 때는 필요가 없고 배포할 때만 등록이 되면
좋겠다.
- 

### 프로파일 정의하기

- 클래스에 정의
    - @Configuration @Profile(“test”)
    - @Component @Profile(“test”)
- 메소드에 정의
    - @Bean @Profile(“test”)

### 프로파일 설정하기

- -Dspring.profiles.avtive=”test,A,B,...”
- [@ActiveProfiles](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/ActiveProfiles.html) (테스트용)

### 프로파일 표현식

- ! (not), & (and), | (or)

## Environment 2부 : 프로퍼티

### 프로퍼티

- 다양한 방법으로 정의할 수 있는 설정값
- Environment의 역할은 프로퍼티 소스 설정 및 프로퍼티 값 가져오기

### 프로퍼티에는 우선 순위가 있다.

- StandardServletEnvironment의 우선순위
    - ServletConfig 매개변수
    - ServletContext 매개변수
    - JNDI (java:comp/env/)
    - JVM 시스템 프로퍼티 (-Dkey=”value”)
    - JVM 시스템 환경 변수 (운영 체제 환경 변수)

### @PropertySource

- [Environment](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/Environment.html)를 통해 프로퍼티 추가하는 방법

### 스프링 부트의 외부 설정 참고

- 기본 프로퍼티 소스 지원 (application.properties)
- 프로파일까지 고려한 계층형 프로퍼티 우선 순위 제공

## MessageSource

- 국제화 (i18n) 기능을 제공하는 인터페이스.
- ApplicationContext extends MessageSource
    - getMessage(String code, Object[] args, String, default, Locale, loc)
    - ...
- 스프링 부트를 사용한다면 별다른 설정 필요없이messages.properties 사용할 수 있음
    - messages.properties
    - messages_ko_kr.properties
    - ...

### 릴로딩 기능이 있는 메시지 소스 사용하기

```java
@Bean
public MessageSource messageSource() {
	var messageSource = new ReloadableResourceBundleMessageSource();
	messageSource.setBasename("classpath:/messages");
	messageSource.setDefaultEncoding("UTF-8");
	messageSource.setCacheSeconds(3);
	return messageSource;
}
```

## ApplicationEventPublisher

- 이벤트 프로그래밍에 필요한 인터페이스 제공. [옵저버 패턴](https://en.wikipedia.org/wiki/Observer_pattern) 구현체.
- ApplicationContext extends [ApplicationEventPublisher](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationEventPublisher.html)
    - publishEvent(ApplicationEvent event)

### 이벤트 만들기

- ApplicationEvent 상속
- 스프링 4.2 부터는 이 클래스를 상속받지 않아도 이벤트로 사용할 수 있다.

### 이벤트 발생 시키는 방법

- ApplicationEventPublisher.publishEvent();
이벤트 처리하는 방법
- ApplicationListener<이벤트> 구현한 클래스 만들어서 빈으로 등록하기.
- 스프링 4.2 부터는 [@EventListener](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/event/EventListener.html)를 사용해서 빈의 메소드에 사용할 수 있다.
- 기본적으로는 synchronized.
- 순서를 정하고 싶다면 @Order와 함께 사용.
- 비동기적으로 실행하고 싶다면 @Async와 함께 사용.

### 스프링이 제공하는 기본 이벤트

- ContextRefreshedEvent: ApplicationContext를 초기화 했더나 리프래시 했을 때 발생.
- ContextStartedEvent: ApplicationContext를 start()하여 라이프사이클 빈들이 시작
신호를 받은 시점에 발생.
- ContextStoppedEvent: ApplicationContext를 stop()하여 라이프사이클 빈들이 정지
신호를 받은 시점에 발생.
- ContextClosedEvent: ApplicationContext를 close()하여 싱글톤 빈 소멸되는 시점에
발생.
- RequestHandledEvent: HTTP 요청을 처리했을 때 발생.

## ResourceLoader

- 리소스를 읽어오는 기능을 제공하는 인터페이스
- ApplicationContext extends ResourceLoader

### 리소스 읽어오기

- 파일 시스템, 클래스 패스, URL, (상대/절대)경로
- Resource getResource(java.lang.String location)

# Resurce / Validation

## Resource 추상화

- [org.springframework.core.io.Resource](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/Resource.html)

### 특징

- java.net.URL을 추상화 한 것.
- 스프링 내부에서 많이 사용하는 인터페이스.

### 추상화 한 이유

- 클래스패스 기준으로 리소스 읽어오는 기능 부재
- ServletContext를 기준으로 상대 경로로 읽어오는 기능 부재
- 새로운 핸들러를 등록하여 특별한 URL 접미사를 만들어 사용할 수는 있지만 구현이
복잡하고 편의성 메소드가 부족하다.

### 인터페이스 둘러보기

- 상속 받은 인터페이스
- 주요 메소드
    - getInputStream()
    - exitst()
    - isOpen()
    - getDescription(): 전체 경로 포함한 파일 이름 또는 실제 URL

### 구현체

- UrlResource: [java.net.URL 참고](https://docs.oracle.com/javase/7/docs/api/java/net/URL.html), 기본으로 지원하는 프로토콜 http, https, ftp, file, jar.
- ClassPathResource: 지원하는 접두어 classpath:
- FileSystemResource
- ServletContextResource: 웹 애플리케이션 루트에서 상대 경로로 리소스 찾는다.
- ...

### 리소스 읽어오기

- Resource의 타입은 locaion 문자열과 ApplicationContext의 타입에 따라 결정 된다.
    - ClassPathXmlApplicationContext -> ClassPathResource
    - FileSystemXmlApplicationContext -> FileSystemResource
    - WebApplicationContext -> ServletContextResource
- ApplicationContext의 타입에 상관없이 리소스 타입을 강제하려면 java.net.URL
접두어(+ classpath:)중 하나를 사용할 수 있다.
    - classpath:me/whiteship/config.xml -> ClassPathResource
    - file:///some/resource/path/config.xml -> FileSystemResource

## Validation 추상화

- [org.springframework.validation.Validator](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/Validator.html)
- 애플리케이션에서 사용하는 객체 검증용 인터페이스.

### 특징

- 어떤한 계층과도 관계가 없다. => 모든 계층(웹, 서비스, 데이터)에서 사용해도 좋다.
- 구현체 중 하나로, JSR-303(Bean Validation 1.0)과 JSR-349(Bean Validation 1.1)을
지원한다. ([LocalValidatorFactoryBean](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html))
- DataBinder에 들어가 바인딩 할 때 같이 사용되기도 한다.

### 인터페이스

- boolean supports(Class clazz): 어떤 타입의 객체를 검증할 때 사용할 것인지 결정함
- void validate(Object obj, Errors e): 실제 검증 로직을 이 안에서 구현
    - 구현할 때 ValidationUtils 사용하며 편리 함.

### 스프링 부트 2.0.5 이상 버전을 사용할 때

- LocalValidatorFactoryBean 빈으로 자동 등록
- - JSR-380(Bean Validation 2.0.1) 구현체로 hibernate-validator 사용.
- [https://beanvalidation.org/](https://beanvalidation.org/)

# 데이터 바인딩

## 데이터 바인딩 추상화 : Property Editor

- [org.springframework.validation.DataBinder](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/DataBinder.html)

### 기술적인 관점

- 프로퍼티 값을 타겟 객체에 설정하는 기능

### 사용자 관점

- 사용자 입력값을 애플리케이션 도메인 모델에 동적으로 변환해 넣어주는 기능.
- 해석하자면: 입력값은 대부분 “문자열”인데, 그 값을 객체가 가지고 있는 int, long, Boolean,
Date, 도메인 타입으로 변환해서 넣어주는 기능.

### 사용처

- spring web mvc에서 많이 사용함
- xml 설정파일에서 문자열을 빈이 가지고 있는 적절한 타입을 넣는 것에도 사용한다.
- SpEL에서도 사용한다.

### [PropertyEditor](https://docs.oracle.com/javase/7/docs/api/java/beans/PropertyEditor.html)

- 스프링 3.0 이전까지 DataBinder가 변환 작업 사용하던 인터페이스
- 쓰레드-세이프 하지 않음 (상태 정보 저장 하고 있음, 따라서 싱글톤 빈으로 등록해서
쓰다가는...)
- Object와 String 간의 변환만 할 수 있어, 사용 범위가 제한적 임. (그래도 그런 경우가
대부분이기 때문에 잘 사용해 왔음. 조심해서..)
- 그러나 이 방법은 빈으로 등록하는 것도 힘들고 하나씩 구현해야 하기 때문에 Spring 3.0부터 새로운 데이터 바인딩 인터페이스가 추가해야 한다.

### 예제 코드

```java
package inflearn.core.databind;

public class Event {
	private final Integer id;

	public Event(final Integer id) {
		this.id = id;
	}

	public Integer getId() {
		return id;
	}

	@Override
	public String toString() {
		return "Event{" +
			"id=" + id +
			'}';
	}
}
```

```java
package inflearn.core.databind;

import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class EventController {

	@InitBinder
	public void init(WebDataBinder webDataBinder){ // 데이터 바인더 등록
		webDataBinder.registerCustomEditor(Event.class, new EventEditor());
	}

	@GetMapping("/events/{event}")
	public String getEvent(@PathVariable Event event){
		System.out.println(event);
		return event.getId().toString();
	}
}
```

```java
package inflearn.core.databind;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;

@ExtendWith(SpringExtension.class)
@WebMvcTest
class EventControllerTest {
	@Autowired
	private MockMvc mockMvc;

	@Test
	void getTest() throws Exception {
		mockMvc.perform(get("/events/1"))
			.andExpect(status().isOk())
			.andExpect(content().string("1"));
	}
}
```

```java
package inflearn.core.databind;

import java.beans.PropertyEditorSupport;

public class EventEditor extends PropertyEditorSupport { // 구현해야 할 메소드만 구현하면 된다.
	
	@Override
	public String getAsText() { // Object -> String
		Event event = (Event) getValue();
		return event.getId().toString();
	}

	@Override
	public void setAsText(final String text) throws IllegalArgumentException { // Text -> Object
		setValue(new Event(Integer.parseInt(text)));
	}
}
```

- 여기서 value가 프로퍼티 애디터가 가지고 있는 값으로 서로 다른 스레드에 공유가 된다. 스테이트 풀하다. 즉, 상태 정보 저장을 하고 있어 쓰레드 세이프하지 않다.
- 빈으로 등록하면 1번회원이 5번회원을 수정하고, 5번 회원이 1번회원을 수정하는 단점이 생긴다.
- 빈 스코프에서 한 쓰레드에서만 사용하도록 하게 할 수 있지만, 그냥 빈으로 등록안하는 것이 좋다.

## 데이터 바인딩 추상화 : Converter와 Formatter

### [Converter](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/Converter.html)

- PropertyEditor의 단점을 보안하고자 나왔다.
- S 타입을 T 타입으로 변환할 수 있는 매우 일반적인 변환기.
- 상태 정보 없음 == Stateless == 쓰레드세이프
- [ConverterRegistry](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/ConverterRegistry.html)에 등록해서 사용
- 기본적으로 등록되어 있는 컨버터나 포맷터가 있는데 그게 뭘까요!?

### 예제코드

```java
package inflearn.core.databind;

import org.springframework.core.convert.converter.Converter;
import org.springframework.lang.Nullable;

public class EventConverter {
	public static class StringToEventConverter implements Converter<String, Event> {
		@Nullable
		@Override
		public Event convert(final String source) {
			return new Event(Integer.parseInt(source));
		}
	}

	public static class EventToStringConverter implements Converter<Event, String> {
		@Nullable
		@Override
		public String convert(final Event source) {
			return source.getId().toString();
		}
	}
}
```

```java
package inflearn.core.databind;

import org.springframework.context.annotation.Configuration;
import org.springframework.format.FormatterRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
	@Override
	public void addFormatters(final FormatterRegistry registry) {
		registry.addConverter(new EventConverter.StringToEventConverter());
		registry.addConverter(new EventConverter.EventToStringConverter());
	}
}
```

```java
```java
package inflearn.core.databind;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ConverterEventController {
	@GetMapping("con/events/{event}")
	public String getEvent(@PathVariable Event event){
		System.out.println(event);
		return event.getId().toString();
	}
}

```

```java
package inflearn.core.databind;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;

@ExtendWith(SpringExtension.class)
@WebMvcTest
class ConverterEventControllerTest {
	@Autowired
	private MockMvc mockMvc;

	@Test
	void getTest() throws Exception {
		mockMvc.perform(get("con/events/1"))
			.andExpect(status().isOk())
			.andExpect(content().string("1"));
	}
}
```

### [Formatter](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/ConverterRegistry.html)

- PropertyEditor 대체제
- Object와 String 간의 변환을 담당한다.
- 문자열을 Locale에 따라 다국화하는 기능도 제공한다. (optional)
- [FormatterRegistry](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/format/FormatterRegistry.html)에 등록해서 사용
- Formatter를 처리할 객체를 제네릭을 등록해서 두개의 메서드(Stirng → Obejct, Object → String)을 등록한다.
- 빈으로 등록 가능하다.
    - `MessageResource`를 주입받아서 필요한 메시지를 추출해서 그 locale에 맞는 메시지를 반환할 수 있다.

```java
package inflearn.core.databind;

import java.text.ParseException;
import java.util.Locale;

import org.springframework.format.Formatter;

public class EventFormatter implements Formatter<Event> {

	@Override
	public Event parse(final String text, final Locale locale) throws ParseException {
		return new Event(Integer.parseInt(text));
	}

	@Override
	public String print(final Event object, final Locale locale) {
		return object.getId().toString();
	}
}
```

```java
package inflearn.core.databind;

import org.springframework.context.annotation.Configuration;
import org.springframework.format.FormatterRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
	@Override
	public void addFormatters(final FormatterRegistry registry) {
		registry.addFormatter(new EventFormatter());
	}
}
```

```java
package inflearn.core.databind;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class FormatterEventController {
	@GetMapping("for/events/{event}")
	public String getEvent(@PathVariable Event event) {
		System.out.println(event);
		return event.getId().toString();
	}
}
```

```java
package inflearn.core.databind;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;

@ExtendWith(SpringExtension.class)
@WebMvcTest
class FormatterEventControllerTest {
	@Autowired
	private MockMvc mockMvc;

	@Test
	void getTest() throws Exception {
		mockMvc.perform(get("/for/events/1"))
			.andExpect(status().isOk())
			.andExpect(content().string("1"));
	}
}
```

### [ConversionService](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/ConversionService.html)

- 데이터 바인더가 아니라, converter랑 formatter는 이걸 사용한다.
- 실제 변환 작업은 이 인터페이스를 통해서 쓰레드-세이프하게 사용할 수 있음.
- 스프링 MVC, 빈 (value) 설정, SpEL에서 사용한다.
- DefaultFormattingConversionService
    - FormatterRegistry
    - ConversionService
    - 여러 기본 컴버터와 포매터 등록 해 줌.
    - converter Registry가 formatter Registry를 상속받고 있기 때문에 설정 파일에서 formatter Registry에 converter를 등록할 수 있다.
    - 왜 이렇게 상속을 받게 했을까?

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09df84ac-2a79-4c5a-8872-86e3da3663e3/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09df84ac-2a79-4c5a-8872-86e3da3663e3/Untitled.png)

### 스프링 부트

- 웹 애플리케이션인 경우에 DefaultFormattingConversionSerivce를 상속하여 만든
WebConversionService를 빈으로 등록해 준다.
- 즉, 스프링 부트에서 WebConversionService를 제공한다
- Formatter와 Converter 빈을 찾아 자동으로 등록해 준다.
- Converter나 Formatter를 빈으로 등록한다면 registory에 추가하지 않아도 자동으로 스프링부트가 등록해준다.

```java
package inflearn.core.databind;

import java.text.ParseException;
import java.util.Locale;

import org.springframework.format.Formatter;
import org.springframework.stereotype.Component;

@Component
public class EventFormatter implements Formatter<Event> {

	@Override
	public Event parse(final String text, final Locale locale) throws ParseException {
		return new Event(Integer.parseInt(text));
	}

	@Override
	public String print(final Event object, final Locale locale) {
		return object.getId().toString();
	}
}
```

```java
package inflearn.core.databind;

import org.springframework.core.convert.converter.Converter;
import org.springframework.lang.Nullable;
import org.springframework.stereotype.Component;

public class EventConverter {
	@Component
	public static class StringToEventConverter implements Converter<String, Event> {
		@Nullable
		@Override
		public Event convert(final String source) {
			return new Event(Integer.parseInt(source));
		}
	}

	@Component
	public static class EventToStringConverter implements Converter<Event, String> {
		@Nullable
		@Override
		public String convert(final Event source) {
			return source.getId().toString();
		}
	}
}
```

### Conversion Service

- 웹 애플리케이션(스프링 부트)인 경우에 DefaultFormattingConversionSerivce를 상속하여 만든
WebConversionService를 빈으로 등록해 준다.
- 자기가 가지고 있는 포맷터랑 컨버터를 사용할 수 있도록 한다. (canConverter()를 이용해 가능한지 확인하고 converter()를 사용해 컨버터를 한다.)

```java
package inflearn.core.databind;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.convert.ConversionService;
import org.springframework.stereotype.Component;

@Component
public class AppRunner implements ApplicationRunner {

	private final ConversionService conversionService;

	public AppRunner(final ConversionService conversionService) {
		this.conversionService = conversionService;
	}

	@Override
	public void run(final ApplicationArguments args) throws Exception {
		System.out.println(
			conversionService.getClass().toString()); // conversionService를 호출했지만 스프링 부트로 인해 WebConversionService가 호출된다.

		boolean isConverter = conversionService.canConvert(Event.class, String.class); // 컨버터가 가능한지 확인한다.
		System.out.println(isConverter);
		Event convert = conversionService.convert("1", Event.class); // 실제 컨버터를 한다.
		System.out.println(convert);
	}
}
```

### WebConversionService

- 어느 기능을 확장했는지 확인하자.

### WebMvcTest

- 슬라이싱 테스트로 웹과 관련된 빈들만 등록한다.
- 포맷터나 컨버터를 빈으로 등록해서 사용한다면 WebMvcTest()에 등록해줘야 한다.

```java
@WebMvcTest({Eventconvter.StringToEventConverter.class, EventConverter.EventToStringConvter.class})
```

### JPA

- JPA Entity는 컨버터를 제공한다.(JPA에서)

### 컨버터 확인

```java
package inflearn.core.databind;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.convert.ConversionService;
import org.springframework.stereotype.Component;

@Component
public class AppRunner implements ApplicationRunner {

	private final ConversionService conversionService;

	public AppRunner(final ConversionService conversionService) {
		this.conversionService = conversionService;
	}

	@Override
	public void run(final ApplicationArguments args) throws Exception {
		System.out.println(conversionService); // 전체 converter, formatter 확인
	}
}
```

# SpEL

## SpEL(Spring Expression Language)

### [스프링 EL](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions)이란?

- 객체 그래프를 조회하고 조작하는 기능을 제공한다.
    - 객체 그래프란?

- Unified EL과 비슷하지만, 메소드 호출을 지원하며, 문자열 템플릿 기능도 제공한다.
    - Unifited EL이란?

- OGNL, MVEL, JBOss EL 등 자바에서 사용할 수 있는 여러 EL이 있지만, SpEL은
모든 스프링 프로젝트 전반에 걸쳐 사용할 EL로 만들었다.
- 스프링 3.0 부터 지원.
- 리터럴, 프로퍼티, 배열, 리스트, 맵, 인덱스 연산자, 메소드 호출, 빈의 정보 참고 등 모두 지원한다.

### SpEL 구성

- ExpressionParser parser = new SpelExpressionParser()
    - 이해하면 좋다
    - Converter를 사용한다.
- StandardEvaluationContext context = new StandardEvaluationContext(bean)
    - 이해하면 좋다.
- Expression expression = parser.parseExpression(“SpEL 표현식”)
- String value = expression.getvalue(context, String.class)

### 문법

- `@Value()`를 사용하면 SpEL을 사용 가능하다.
- 문자열 대로도 넣을 수 있다.
    - @Value("hello")
- #{“표현식"}
    - @Value("#{1 + 1}")
- ${“프로퍼티"}
- 표현식은 프로퍼티를 가질 수 있지만, 반대는 안 됨.
    - #{${my.data} + 1}
- Bean 필드
    - getter가 필요하다

```java
import org.springframework.stereotype.Component;

@Component
public class Sample {
	private final int data;

	public Sample() {
		this.data = 200;
	}

	public int getData() {
		return data;
	}
}
```

```java
@Value("#{sample.data}")
	private int sampleData;
```

- 메소드 호출
    - 예제코드 추가
- [레퍼런스 참고](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions-language-ref)

### 사용하는 곳

- @Value 애노테이션
- @ConditionalOnExpression 애노테이션
    - 선택적으로 빈을 등록하거나 빈 설정 파일을 읽어 오는 것인데, SpEL을 이용해 조건을 줄 수 있다.
- [스프링 시큐리티](https://docs.spring.io/spring-security/site/docs/3.0.x/reference/el-access.html)
    - 메소드 시큐리티, @PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter
    - XML 인터셉터 URL 설정
        - StandardEvaluationContext 여기서 온다.
    - ...
- 스프링 데이터
    - [@Query](https://spring.io/blog/2014/07/15/spel-support-in-spring-data-jpa-query-definitions) 애노테이션
        - `@Param` 값을 쿼리 애노테이션에 쓸수 있다.
- [Thymeleaf](https://blog.outsider.ne.kr/997)
- ...

## 예제코드

```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.stereotype.Component;

@Component
public class AppRunner implements ApplicationRunner {

	@Value("#{1 + 1}")
	private int value;

	@Value("#{'hello' + 'world'}")
	private String greeting;

	@Value("#{1 eq 1}")
	private boolean trueOfFalse;

	@Value("${my.value}")
	private int myValue;

	@Value("#{${my.value} eq 100}")
	private boolean isMyValue;

	@Value("#{sample.data}")
	private int sampleData;

	@Override
	public void run(final ApplicationArguments args) throws Exception {
		System.out.println(value);
		System.out.println(greeting);
		System.out.println(trueOfFalse);
		System.out.println(myValue);
		System.out.println(isMyValue);
		System.out.println(sampleData);

		
		ExpressionParser expressionParser = new SpelExpressionParser();
		Expression expression = expressionParser.parseExpression("2 + 100");
		Integer value = expression.getValue(Integer.class);
		System.out.println(value);
	}
}
```

```java

import org.springframework.stereotype.Component;

@Component
public class Sample {
	private final int data;

	public Sample() {
		this.data = 200;
	}

	public int getData() {
		return data;
	}
}
```

- ApplicationProperty

```java
my.value = 100
```

# 스프링 AOP

- [AOP를 왜 사용하는지, 어떻게 사용하는지 실습](https://github.com/ksy90101/TIL/blob/master/spring/AOP.md)

- AOP를 구현하는 기능과 AspectJ와 같이 사용할 수 있도록 하는 기능을 제공하며 자체 AOP 기능들을 제공한다
- 트랜잭션이나, 캐시 등을 위해 사용한다.

## 개념 소개

- Aspect-oriendted Programming (AOP)은 OOP를 보완하는 수단으로, 흩어진 Aspect를
모듈화 할 수 있는 프로그래밍 기법.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ca4dece4-fc45-482d-bbd1-5f5eacbd1dac/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ca4dece4-fc45-482d-bbd1-5f5eacbd1dac/Untitled.png)

- 예를 들어 트랜잭션 처리(setAutoCommit을 false로 하고 쿼리를 실행하고 커밋이나 롤백을 하는 작업)을 한다면, 기존에 잇던 서비스 코드를 다 감싸야 한다.
- 두번째 예는 성능 로깅을 하는 메소드를 모든 코드에 적용을 한다면. 그 코드를 감싸야 한다.
- 이때, 이걸 사용하려면 모든 코드에 그 코드들을 감싸야 한다.
- 이걸 해결하기 위해 Aspect를 이용한다.
- Aspect를 구현하고 이 Aspect를 어디에 적용해야 하는지 개발자가 명시해준다.

### AOP 주요 개념

- Aspect와 Target
    - Aspect는 하나의 모듈 = Advice + PointCut
    - Target은 적용할 대상
- Advice
    - Aspect의 기능(해야할 일)
- Join point와 Pointcut
    - Pointcut은 어디에 Aspect를 적용할지 나타내는 것이다.
    - Join point는 메소드 실행 시점이다. 언제 실행할지를 나타내는 것이다.

### AOP 구현체

- [https://en.wikipedia.org/wiki/Aspect-oriented_programming](https://en.wikipedia.org/wiki/Aspect-oriented_programming)
- 자바
    - AspectJ
        - 다양한 조인포인트와 다양한 기능들을 제공한다.
    - 스프링 AOP
        - 스프링에 필요한 조인포인트와 기능들만 제공한다.

### AOP 적용 방법

- 컴파일
    - java → class // 이미 조작된 바이트 코드를 생성하는 것이다.
    - 성능부하가 적지만, 별도의 컴파일 과정을 한 번더 거쳐야 한다.
- 로드 타임
    - Class는 그 자체를 컴파일 하고, 이 Class 로딩하는 시점에 Aspect를 적용하는 것이다.
    - 성능 부하가 발생할 수 있으며, 로드 타임 Weaving을 설정해야 하지만, AspectJ를 사용할 수 있다.
- 런타임
    - Bean을 만들때, Proxy Bean을 만들어 실제 Bean을 감싸서 Bean이 실행될때 Asepct를 실행시키고 Bean을 실행시킨다.
    - Spring AOP가 사용하는 방법으로 실제 요청이 들어올때마다 적용하는 것이 아니라 Bean을 만드는 과정에서 적용하는 것이기 때문에 로드 타임과 성능 부하가 비슷할 것이다.
    - 아무런 설정을 할 필요가 없으며 문법이 쉽다.(스프링AOP에서 지원하기 때문이다.)

- 컴파일 vs 런타임
- 왜 컴파일은 성능부하가 적고, 로드타임과 런타임을 성능부하가 생길까?
- 각 적용시점을 스프링에서 어떻게 할 수 있을까?

## 프록시 기반 AOP

### 스프링 AOP 특징

- 프록시 기반의 AOP 구현체
- 스프링 빈에만 AOP를 적용할 수 있다.
- 모든 AOP 기능을 제공하는 것이 목적이 아니라, 스프링 IoC와 연동하여 엔터프라이즈
애플리케이션에서 가장 흔한 문제에 대한 해결책을 제공하는 것이 목적.

### 프록시 패턴

- 사용하는 이유
    - (기존 코드 변경 없이) 접근 제어 또는 부가 기능 추가

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2421e3b1-4d6c-4260-b479-efef158b5f95/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2421e3b1-4d6c-4260-b479-efef158b5f95/Untitled.png)

- 기존 코드를 건드리지 않고 성능을 측정해 보자. (프록시 패턴으로)

### 기존 코드

```java
package inflearn.core.aop;

// Subject
public interface EventService {
	void createEvent();

	void publishEvent();
}
```

```java
package inflearn.core.aop;

import org.springframework.stereotype.Service;

// Real Subject
@Service
public class SampleEventService implements EventService {
	@Override
	public void createEvent() {
		try{
			Thread.sleep(1000); // 1초 쉬고 실행
		}catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("Created an Event");
	}

	@Override
	public void publishEvent() {
		try{
			Thread.sleep(2000); // 2초 쉬고 실행
		}catch (InterruptedException e) {
			e.printStackTrace();
		}

		System.out.println("Published an Event");
	}
}
```

```java
package inflearn.core.aop;

import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

// Client
@Component
public class AppRunner implements ApplicationRunner {

	private final EventService eventService;

	public AppRunner(final EventService eventService) {
		this.eventService = eventService;
	}

	@Override
	public void run(final ApplicationArguments args) throws Exception {
		eventService.createEvent();
		eventService.publishEvent();
	}
}
```

### 성능 측정 로직 추가

```java
package inflearn.core.aop;

import org.springframework.stereotype.Service;

// Real Subject
@Service
public class SampleEventService implements EventService {
	@Override
	public void createEvent() {
		long startTime = System.currentTimeMillis();
		try{
			Thread.sleep(1000); // 1초 쉬고 실행
		}catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("Created an Event");
		
		long endTime = System.currentTimeMillis();
		
		System.out.println("걸린 시간 : " + endTime + startTime);
	}

	@Override
	public void publishEvent() {
		long startTime = System.currentTimeMillis();

		try{
			Thread.sleep(2000); // 2초 쉬고 실행
		}catch (InterruptedException e) {
			e.printStackTrace();
		}

		System.out.println("Published an Event");

		long endTime = System.currentTimeMillis();

		System.out.println("걸린 시간 : " + endTime + startTime);
	}
}
```

- 현재 중복코드가 존재한다.(성능 시간 측정 기능)
- 하나의 메소드에서 두개의 기능을 제공한다.

```java
package inflearn.core.aop;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

@Primary // 똑같은 Bean이 여러개있을 때 이걸 바라보기를 적용 
@Service
public class ProxySampleEventService implements EventService{

   private final SampleEventService sampleEventService;

   public ProxySampleEventService(final SampleEventService sampleEventService) {
      this.sampleEventService = sampleEventService;
   }

   @Override
   public void createEvent() {
      long startTime = System.currentTimeMillis();
      sampleEventService.createEvent();
      long endTime = System.currentTimeMillis();
      System.out.println("걸린 시간 : " + endTime + startTime);
   }

   @Override
   public void publishEvent() {
      long startTime = System.currentTimeMillis();
      sampleEventService.deleteEvent();
      long endTime = System.currentTimeMillis();
      System.out.println("걸린 시간 : " + endTime + startTime);  }

   @Override
   public void deleteEvent() {
      sampleEventService.deleteEvent();
   }
}
```

### 문제점

- 매번 프록시 클래스를 작성해야 하는가?
- 여러 클래스 여러 메소드에 적용하려면?
- 객체들 관계도 복잡하고...

### 그래서 등장한 것이 스프링 AOP

- 스프링 IoC 컨테이너가 제공하는 기반 시설과 Dynamic 프록시를 사용하여 여러 복잡한 문제 해결.
- 동적 프록시: 동적으로 프록시 객체 생성하는 방법
    - 자바가 제공하는 방법은 인터페이스 기반 프록시 생성.
    - CGlib은 클래스 기반 프록시도 지원.
- 스프링 IoC: 기존 빈을 대체하는 동적 프록시 빈을 만들어 등록 시켜준다.
    - 클라이언트 코드 변경 없음.
        - [AbstractAutoProxyCreator](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.html) implements [BeanPostProcessor](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html)
        - 빈이 등록되고 스프링이 AutoProxyCreator로 프록시 빈을 만들어 원래 빈 대신 프록시 객체를 빈으로 등록해준다.

## @AOP

- 애노테이션 기반의 스프링 @AOP

### 의존성 추가

```java
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

### 애스팩트 정의

- @Aspect
- 빈으로 등록해야 하니까 (컴포넌트 스캔을 사용한다면) @Component도 추가.

### 포인트컷 정의

- @Pointcut(표현식)
- 주요 표현식
    - execution
    - @annotation
    - bean
- 포인트컷 조합
    - &&, ||, !

### 어드바이스 정의

- @Before
- @AfterReturning
- @AfterThrowing
- @Around

### 예제 코드

```java
package inflearn.core.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class PerfAspect {
	@Around("execution(* inflearn.core.aop.EventService.*(..))") // Pointcut
	// Advice
	public Object logPerf(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { // Aspect가 적용될 이벤트(메서드)
		long startTime = System.currentTimeMillis();
		Object value = proceedingJoinPoint.proceed();
		long endTime = System.currentTimeMillis();
		System.out.println("성능 시간 : " + endTime + startTime);
		return value;
	}
}
```

- 이렇게 하면 실제 메소드 로직을 건들지 않아도 성능 시간 측정 기능을 구현할 수 있다.
- 그러나 아직 문제점이 남았다. pointcut에 구현한 표현식에서 EventService의 모든 메소드에 AOP를 적용해버린 것이다.
- 이걸 해결할 방법중 하나 annotation을 구현해 하면 유용하다.

```java
package inflearn.core.aop;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Documented
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.CLASS)
public @interface PerfLogging {
}
```

```java
package inflearn.core.aop;

import org.springframework.stereotype.Service;

// Real Subject
@Service
public class SampleEventService implements EventService {
	@Override
	@PerfLogging
	public void createEvent() {
		try{
			Thread.sleep(1000); // 1초 쉬고 실행
		}catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("Created an Event");
	}

	@Override
	@PerfLogging
	public void publishEvent() {
		try{
			Thread.sleep(2000); // 2초 쉬고 실행
		}catch (InterruptedException e) {
			e.printStackTrace();
		}

		System.out.println("Published an Event");

		long endTime = System.currentTimeMillis();
	}

	@Override
	public void deleteEvent() { // 성능 시간 측정을 제공하지 않을 메소드
		System.out.println("Deleted an Event");
	}
}
```

### Bean

```java
@Around("bean(evnetService)")
```

### [참고](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-)

# Null-Safety

## Null-safety

### 스프링 프레임워크 5에 추가된 Null 관련 애노테이션

- @NonNull, @NonNullApi (패키지 레벨 설정) : null을 허용하지 않음.
- @Nullable, @NonNullFields (패키지 레벨 설정) : null을 허용함.

### 목적

- Null을 허용하는지, 허용하지 않는지를 설정해 컴파일 시점에 NPE를 방지하는 것이다.

### 예제 코드

```java
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Service;

@Service
public class EventService {
	public String createEvent(@NonNull String name){
		return "hello " + name;
	}
}
```

```java
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class AppRunner implements ApplicationRunner {

	private final EventService eventService;

	public AppRunner(final EventService eventService) {
		this.eventService = eventService;
	}

	@Override
	public void run(final ApplicationArguments args) throws Exception {
		eventService.createEvent(null);
	}
}
```

### IntelliJ 설정

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/235ab04d-0608-42f1-b360-1c95e50697b5/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/235ab04d-0608-42f1-b360-1c95e50697b5/Untitled.png)

- `Add runtime assertions for notnull-annotated methods and parameters` 체크 확인

- CONFIGURE ANNOTATIONS... 클릭 후 Spring Nullalbe과 NonNull을 추가한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e7efc0b-73c0-430f-8de6-335c2c484410/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e7efc0b-73c0-430f-8de6-335c2c484410/Untitled.png)

- 그리고 재시작을 한다.

- 그럼 다음과 같이 경고한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1c6f9f64-55e8-415c-8c85-4c5d751f1234/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1c6f9f64-55e8-415c-8c85-4c5d751f1234/Untitled.png)

### 패키지에 설정하기

```java
@NonNullApi
package inflearn.core.nullsafety;
```