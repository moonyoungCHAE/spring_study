# 스프링 부트 개념과 활용3

## 테스트

- build.gradle

  테스트를 하려면 `org.springframework.boot:spring-boot-starter-test`필요

  ```
  ...
  dependencies {
      ...
      testImplementation('org.springframework.boot:spring-boot-starter-test') {
          exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
      }
  }
  ...
  ```

- SampleController

  ```java
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.RestController;
  
  @RestController
  public class SampleController {
  
      private SampleService sampleService;
  
      public SampleController(SampleService sampleService) {
          this.sampleService = sampleService;
      }
  
      @GetMapping("/hello")
      public String hello() {
          return "hello " + sampleService.getName();
      }
  }
  ```

- SampleService

  ```java
  import org.springframework.stereotype.Service;
  
  @Service
  public class SampleService {
  
      public String getName() {
          return "tiger";
      }
  }
  ```

### TEST

- `@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)`일 때

  `@SpringBootTest`에 `webEnvironment`라는 것이 있는 데 기본 값이 `Mock`으로 잡혀있다.

  `Mock`은 서블릿 컨테이너를 테스트용으로 띄우지 않고 MockUp을 해서 **Dispatcher-Servlet**이 만들어져 비슷하게 테스트할 수 있다.

  그때 MockUp된 서블릿에 interaction 하려면 MockMvc를 사용해야한다.

  SampleControllerTest.class

  ```java
  import org.junit.Test;
  import org.junit.runner.RunWith;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
  import org.springframework.boot.test.context.SpringBootTest;
  import org.springframework.test.context.junit4.SpringRunner;
  import org.springframework.test.web.servlet.MockMvc;
  
  import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
  import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
  import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
  import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
  
  @RunWith(SpringRunner.class)
  @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)
  @AutoConfigureMockMvc
  public class SampleControllerTest {
  
      @Autowired
      MockMvc mockMvc; // 빈에 있는 것을 사용할 수 있다.
  
      @Test
      public void hello() throws Exception {
          mockMvc.perform(get("/hello"))
                  .andExpect(status().isOk())
                  .andExpect(content().string("hello tiger"))
                  .andDo(print());
      }
  }
  ```

- `@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)`일 때

  `@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)`를 사용하면 실제 서블릿이 뜬다. (내장 톰캣 구동)

  ```java
  import org.junit.Test;
  import org.junit.runner.RunWith;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.boot.test.context.SpringBootTest;
  import org.springframework.boot.test.web.client.TestRestTemplate;
  import org.springframework.test.context.junit4.SpringRunner;
  
  import static org.assertj.core.api.Assertions.assertThat;
  
  @RunWith(SpringRunner.class)
  @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
  public class SampleControllerTest {
  
      @Autowired
      TestRestTemplate testRestTemplate;
  
      @Test
      public void hello() {
          String result = testRestTemplate.getForObject("/hello", String.class);
          assertThat(result).isEqualTo("hello tiger");
      }
  }
  ```

  이렇게 사용하게 되면 Test가 Service까지 간다. Controller까지만 가고싶다.

  그러면 이렇게 하면 된다.

  ```java
  import org.junit.Test;
  import org.junit.runner.RunWith;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.boot.test.context.SpringBootTest;
  import org.springframework.boot.test.mock.mockito.MockBean;
  import org.springframework.boot.test.web.client.TestRestTemplate;
  import org.springframework.test.context.junit4.SpringRunner;
  
  import static org.mockito.Mockito.when;
  
  @RunWith(SpringRunner.class)
  @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
  public class SampleControllerTest {
  
      @Autowired
      TestRestTemplate testRestTemplate;
  
      @MockBean // MockBean으로 Service를 만들어 사용한다.
      SampleService sampleService;
  
      @Test
      public void hello() {
          when(sampleService.getName()).thenReturn("tiger"); // Mocking 해줘야 한다.
  
          String result = testRestTemplate.getForObject("/hello", String.class);
          assertThat(result).isEqualTo("hello tiger");
      }
  }
  ```

  `WebTestClient`를 사용하여 **Asynchronous**(비동기)하게 동작 시킬 수 있다.

  `WebTestClient`를 사용하려면 build.gradle에 `implementation 'org.springframework.boot:spring-boot-starter-webflux'`를 추가한다.

  ```java
  import org.junit.Test;
  import org.junit.runner.RunWith;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.boot.test.context.SpringBootTest;
  import org.springframework.boot.test.mock.mockito.MockBean;
  import org.springframework.test.context.junit4.SpringRunner;
  import org.springframework.test.web.reactive.server.WebTestClient;
  
  import static org.assertj.core.api.Assertions.assertThat;
  import static org.mockito.Mockito.when;
  
  @RunWith(SpringRunner.class)
  @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
  public class SampleControllerTest {
  
      @Autowired
      WebTestClient webTestClient;
  
      @MockBean
      SampleService sampleService;
  
      @Test
      public void hello() {
          when(sampleService.getName()).thenReturn("tiger");
  
          webTestClient.get().uri("/hello").exchange()
                  .expectStatus().isOk()
                  .expectBody(String.class).isEqualTo("hello tiger");
      }
  }
  ```

- `@WebMvcTest(SampleController.class)`는 슬라이싱 용이다. 
  
  - 일반적인 `@Component`들 의존성이 끊긴다.
  - 따라서 의존성이 있다면 `@MockBean`만들어야 한다.
  
- OutputCapture은 생략한다.

## Spring-Boot-Devtools

> `implementation('org.springframework.boot:spring-devtools')` 추가

- 캐시 설정을 개발 환경에 맞게 변경
- 클래스패스에 있는 파일이 변경 될때마다 자동으로 재시작
- 백기선 선생님은 안 쓸거 같다고 하셔서 여기까지 정리하겠다.

## 스프링 웹 MVC

### 1부 소개

기본적인 테스트를 해보자

- UserControllerTest

  ```java
  import org.junit.Test;
  import org.junit.runner.RunWith;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
  import org.springframework.test.context.junit4.SpringRunner;
  import org.springframework.test.web.servlet.MockMvc;
  
  import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
  
  @RunWith(SpringRunner.class)
  @WebMvcTest(UserController.class)
  public class UserControllerTest {
  
      @Autowired
      MockMvc mockMvc;
  
      @Test
      public void hello() throws Exception {
          mockMvc.perform(get("/hello"))
                  .andExpect(status().isOk())
                  .andExpect(content().string("hello"));
      }
  }
  ```

- UserController

  ```java
  import org.springframework.web.bind.annotation.*;
  
  @RestController
  public class UserController {
  
      @GetMapping("/hello")
      public String hello() {
          return "hello";
      }
  }
  ```

Spring Boot MVC가 제공하는 설정을 바꿀 수 있다. (추가적인 설정)

`config`팩토리 안에 `WebConfig.class`를 만들어 준다.

```java
package me.tiger.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    
}
```

만약 `@EnableWebMvc`를 사용한다면 스프링 부트가 제공하는 기본설정은 사라지고 본인이 설정을 해야한다.

### 2부 HttpMessageConverters

`HttpMessageConverters`: HTTP 요청 본문을 객체로 변경하거나, 객체를 HTTP 응답 본문으로 변결할 때 사용

- UserController

  ```java
  import org.springframework.web.bind.annotation.*;
  
  @RestController // @RestController는 기본적으로 @ResponseBody를 제공한다.
  public class UserController {
  
      @PostMapping("/users/create")
      public User create(@RequestBody User user) {
          return user;
      }
  }
  ```

- User

  ```java
  public class User {
      private Long id;
      private String username;
      private String password;
  
      public Long getId() {
          return id;
      }
  
      public void setId(Long id) {
          this.id = id;
      }
  
      public String getUsername() {
          return username;
      }
  
      public void setUsername(String username) {
          this.username = username;
      }
  
      public String getPassword() {
          return password;
      }
  
      public void setPassword(String password) {
          this.password = password;
      }
  }
  ```

- UserControllerTest

  ```java
  @RunWith(SpringRunner.class)
  @WebMvcTest(UserController.class)
  public class UserControllerTest {
  
      @Autowired
      MockMvc mockMvc;
  
      @Test
      public void crateUser_JSON() throws Exception {
          String userJson = "{\"username\":\"tiger\", \"password\":\"123\"}";
          mockMvc.perform(post("/users/create")
              .contentType(MediaType.APPLICATION_JSON)
              .accept(MediaType.APPLICATION_JSON)
              .content(userJson))
                  .andExpect(status().isOk())
                  .andExpect(jsonPath("$.username", is(equalTo("tiger"))))
                  .andExpect(jsonPath("$.password", is(equalTo("123"))));
      }
  }
  ```

### 3부 ViewResolve

- 요청의 accept header에 따라 응답이 달라진다.
- 요청에 응답을 만들 수 있는 View를 찾아 최종적으로 accept header랑 비교해 선택하여 View를 리턴한다.
- 어떤 View를 원하는가 판단하기 가장 좋은 정보는 accept header이다.

요청은 JSON으로 보내고 응답은 XML로 받아보자.

XML 메시지 컨버터 추가하기

`implementation('com.fasterxml.jackson.dataformat:jackson-dataformat-xml')`추가

```java
@RunWith(SpringRunner.class)
@WebMvcTest(UserController.class)
public class UserControllerTest {

    @Autowired
    MockMvc mockMvc;

    @Test
    public void crateUser_XML() throws Exception {
        String userJson = "{\"username\":\"tiger\", \"password\":\"123\"}";
        mockMvc.perform(post("/users/create")
            .contentType(MediaType.APPLICATION_JSON)
            .accept(MediaType.APPLICATION_XML)
            .content(userJson))
                .andExpect(status().isOk())
                .andExpect(xpath("/User/username").string("tiger"))
                .andExpect(xpath("/User/password").string(equalTo("123")));
    }
}
```

### 4부 정적 리소스 지원

- resources/static/hello.html

  ```html
  <!doctype html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport"
            content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
  </head>
  <body>
      Hello Static Resource
  </body>
  </html>
  ```

  `localhost:8080/hello.html`로 접근할 수 있다.

만약 `application.properties`에 `spring.mvc.static-path-pattern=/static/**`라고 설정하면 `localhost:8080/static/hello.html`으로 접근해야 한다.

또한 webconfig를 만들어서 수정할 수 있다.

- config/WebConfig.class

  ```java
  import org.springframework.context.annotation.Configuration;
  import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
  import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
  
  @Configuration
  public class WebConfig implements WebMvcConfigurer {
      @Override
      public void addResourceHandlers(ResourceHandlerRegistry registry) {
          registry.addResourceHandler("/m/**")
                  .addResourceLocations("classpath:/m/")
                  .setCachePeriod(20);
      }
  }
  ```

- resources/m/hello.html

  ```html
  <!doctype html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport"
            content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
  </head>
  <body>
      Hello World
  </body>
  </html>
  ```

`localhost:8080/m/hello.html`로 접근이 가능하다.

### 5부 웹JAR

클라이언트에서 사용하는 자바스크립트 라이브러리(jquery, bootstrap 등) Jar파일로 추가할 수 있다.

예를 들면`implementation group: 'org.webjars.bower', name: 'jquery', version: '3.3.1'`추가하면 jquery를 사용할 수 있다.

```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    Hello Static Resource
<script src="/webjars/jquery/3.3.1/dist/jquery.min.js"></script>
<script>
    $(function() {
        alert("ready!");
    });
</script>
</body>
</html>
```

여기서 `<script src="/webjars/jquery/3.3.1/dist/jquery.min.js"></script>`의 버전을 생략하고 싶다면 `implementation group: 'org.webjars', name: 'webjars-locator-core', version: '0.45'`를 의존성에 추가하면 된다. 그럼 `<script src="/webjars/jquery/dist/jquery.min.js"></script>` 이렇게 사용가능하다.

### 6부 index 페이지와 파비콘

웰컴 페이지

- index.html 찾아 보고 있으면 제공.
- index.템플릿 찾아 보고 있으면 제공.
- 둘 다 없으면 에러 페이지.

파비콘

- 파비콘을 만들어서 resources/static(기본설정)에 favicon.ico를 만들면 된다.











