# 스프링 부트 개념과 활용5

## 스프링 데이터 JPA 소개

ORM(Object-Relational Mapping)과 JPA (Java Persistence API)

- 객체와 릴레이션을 맵핑할 때 발생하는 개념적 불일치를 해결하는 프레임워크
- http://hibernate.org/orm/what-is-an-orm/
- JPA: ORM을 위한 자바 (EE) 표준

스프링 데이터 JPA

- Repository 빈 자동 생성
- 쿼리 메소드 자동 구현
- @EnableJpaRepositories (스프링 부트가 자동으로 설정 해줌.)
- SDJ -> JPA -> Hibernate -> Datasource

## 스프링 데이터 JPA 연동

gradle 의존성 추가

```
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
runtimeOnly 'com.h2database:h2'
```

스프링 데이터 JPA 사용하기

- @Entity 클래스 만들기
- Repository 만들기

스프링 데이터 리파지토리 테스트 만들기

- H2 DB를 테스트 의존성에 추가하기
- @DataJpaTest (슬라이스 테스트) 작성

슬라이스 테스트 - Repository와 관련된 Bean들만 등록을 해서 테스트를 만드는 것

Account.class

```java
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Account {
    @Id @GeneratedValue
    private Long id;

    private String username;

    private String password;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

AccountRepository.class

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

public interface AccountRepository extends JpaRepository<Account, Long> {
//    @Query(nativeQuery = true, value = "select * from account where username = '{0}'")
//    이렇게 커스텀 할 수 있다.
    Account findByUsername(String username);
//    Optional<Account> findByUsername(String username); 이것도 가능
}
```

AccountRepositoryTest.class

```java
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.junit4.SpringRunner;

import javax.sql.DataSource;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.SQLException;

import static org.assertj.core.api.Assertions.assertThat;

@RunWith(SpringRunner.class)
@DataJpaTest
public class AccountRepositoryTest {


    @Autowired
    DataSource dataSource;

    @Autowired
    JdbcTemplate jdbcTemplate;

    @Autowired
    AccountRepository accountRepository;

    @Test
    public void di() throws SQLException {
//        확인용        
//        try (Connection connection = dataSource.getConnection()) {
//            DatabaseMetaData metaData = connection.getMetaData();
//            System.out.println(metaData.getURL());
//            System.out.println(metaData.getDriverMinorVersion());
//            System.out.println(metaData.getUserName());
//        }
        Account account = new Account();
        account.setUsername("tigger");
        account.setPassword("pass");

        Account newAccount = accountRepository.save(account);
        assertThat(newAccount).isNotNull();

        Account existingAccount = accountRepository.findByUsername(newAccount.getUsername());
        assertThat(existingAccount).isNotNull();

        Account nonExistingAccount = accountRepository.findByUsername("bear");
        assertThat(nonExistingAccount).isNull();
        
//        Optional<Account> existingAccount = accountRepository.findByUsername(newAccount.getUsername());
//        assertThat(existingAccount).isNotEmpty();

//        Optional<Account> nonExistingAccount = accountRepository.findByUsername("bear");
//        assertThat(nonExistingAccount).isEmpty();
    }
}
```

## 데이터베이스 초기화

JPA를 사용한 데이터베이스 초기화

- spring.jpa.hibernate.ddl-auto
  - create: 초반에 지우고 만들어 준다.
  - create-drop: 처음에 만들어 주고 종료시 스키마를 지운다.
  - update: 기존에 있는 스키마를 냅두고 변경된 것을 추가한다.
  - validate: Entity 맵핑이 relation DB에 맵핑할 수 있는 상황인지 검증
- spring.jpa.generate-dll=true로 설정 해줘야 동작함. 
  - dll에 변경을 가할 것이 아니라면 false(spring.jpa.hibernate.ddl-auto=validate일 때 사용했다.)

SQL 스크립트를 사용한 데이터베이스 초기화

- schema.sql 또는 schema-${platform}.sql

- data.sql 또는 data-${platform}.sql

- ${platform} 값은 spring.datasource.platform 으로 설정 가능.

  schema-postgresql.sql을 사용한다면

  ```
  spring.datasource.platform=postgresql
  ```

## 데이터베이스 마이그레이션

Flyway와 Liquibase가 대표적인데, 지금은 Flyway를 사용하겠습니다.

gradle 의존성 추가

```
implementation 'org.flywaydb:flyway-core'
```

- resources/db/migration

  V1__init.sql

  ```
  drop table if exists account;
  drop sequence if exists hibernate_sequence;
  create sequence hibernate_sequence start with 1 increment by 1;
  create table account (id bigint not null, password varchar(255), username varchar(255), primary key (id));
  ```

application.properties

```
spring.h2.console.enabled=true

spring.jpa.hibernate.ddl-auto=validate
spring.jpa.generate-dll=false
spring.jpa.show-sql=true
```

만약 여기서 Account.class에 boolean active를 추가하면 어떨까?

```java
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Account {
    @Id @GeneratedValue
    private Long id;

    private String username;

    private String password;

    private boolean active;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public boolean isActive() {
        return active;
    }

    public void setActive(boolean active) {
        this.active = active;
    }
}
```

서버 실행 시 오류가 뜰 것이다.

테이블에 active가 없기 때문인데 여기서 V1__init.sql를 수정하면 안된다. 한번 정의했다면 수정할 수 없다.

따라서 V2__add_active.sql를 만들어 준다.

```
ALTER TABLE account ADD COLUMN active BOOLEAN;
```

마이그레이션 파일 이름

- V숫자__이름.sql
- V는 꼭 대문자로.
- 숫자는 순차적으로 (타임스탬프 권장)
- 숫자와 이름 사이에 언더바 두 개. 
- 이름은 가능한 서술적으로.





