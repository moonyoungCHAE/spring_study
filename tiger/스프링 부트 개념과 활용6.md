# 스프링 부트 개념과 활용6

## 스프링 시큐리티 1부: spring-boot-start-security

스프링 시큐리티

- 웹 시큐리티
- 메소드 시큐리티
- 다양한 인증 방법 지원
  - LDAP, 폼 인증, Basic 인증, OAuth, ...

```java
// HelloController.class
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "hello";
    }

    @GetMapping("/my")
    public String my() {
        return "my";
    }

}
```

resources/templates

```html
// index.html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<h1>Welcome</h1>
<a href="/hello">Hello</a>
<a href="/my">my</a>
</body>
</html>
```

```html
<!-- hello.html -->
<h1>hello</h1>
```

```html
<!-- my.html -->
<h1>my</h1>
```

```java
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;

@RunWith(SpringRunner.class)
@WebMvcTest(HomeController.class)
public class HomeControllerTest {

    @Autowired
    MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        mockMvc.perform(get("/hello"))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(view().name("hello"));
    }

    @Test
    public void my() throws Exception {
        mockMvc.perform(get("/my"))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(view().name("my"));
    }
}
```

정상적으로 테스트가 돌아가는 것을 확인할 수 있다.

gradle 의존성 추가

```
implementation 'org.springframework.boot:spring-boot-starter-security'
```

테스트는 Fail이 나오고, 서버를 켜서 브라우저를 확인하면 로그인하라는 페이지를 확인할 수 있다.

security 의존성을 추가했기 때문이다. (모든 요청에 인증이 필요함. username = user, password = 콘솔에서 확인)

Test위한 gradle 의존석을 추가한다.

```
testImplementation 'org.springframework.security:spring-security-test'
```

```java
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;

@RunWith(SpringRunner.class)
@WebMvcTest(HomeController.class)
public class HomeControllerTest {

    @Autowired
    MockMvc mockMvc;

    @Test
    @WithMockUser
    public void hello() throws Exception {
        mockMvc.perform(get("/hello"))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(view().name("hello"));
    }

    @Test
    public void hello_without_user() throws Exception {
        mockMvc.perform(get("/hello"))
                .andDo(print())
                .andExpect(status().isUnauthorized());
    }

    @Test
    @WithMockUser
    public void my() throws Exception {
        mockMvc.perform(get("/my"))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(view().name("my"));
    }
}
```

## 스프링 시큐리티 2부: 시큐리티 설정 커스터마이징

현재 security를 추가하면 모든 페이지에 대해 인증을 받아야 한다.

하지만 커스텀할 수 있다.

config/SecurityConfig.class

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers("/", "/hello").permitAll()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .and()
            .httpBasic();
    }
}
```

이렇게 하면 "/", "/hello"에서 허가(permit)하여 인증없이 페이지에 접근할 수 있다.

User를 만들어 보자

```java
// Account.class
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Account {

    @Id @GeneratedValue
    private Long id;

    private String username;

    private String password;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

```java
// AccountRepositoty.interface
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface AccountRepository extends JpaRepository<Account, Long> {
    Optional<Account> findByUsername(String username);
}
```

```java
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.Collection;
import java.util.Optional;

@Service
public class AccountService implements UserDetailsService {

    private AccountRepository accountRepository;
    private PasswordEncoder passwordEncoder;

    public AccountService(AccountRepository accountRepository, PasswordEncoder passwordEncoder) {
        this.accountRepository = accountRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public Account createAccount(String username, String password) {
        Account account = new Account();
        account.setUsername(username);
        account.setPassword(passwordEncoder.encode(password)); // password를 encoding해서 set 한다.
        return accountRepository.save(account);
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<Account> byUsername = accountRepository.findByUsername(username);
        Account account = byUsername.orElseThrow(() -> new UsernameNotFoundException(username));

        return new User(account.getUsername(), account.getPassword(), authorities());
    }

    private Collection<? extends GrantedAuthority> authorities() {
        return Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"));
    }
}
```

```java
import com.example.securitytwo.account.Account;
import com.example.securitytwo.account.AccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class AccountRunner implements ApplicationRunner {
    @Autowired
    AccountService accountService;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        Account tigger = accountService.createAccount("tigger", "1234"); // user 생성
        System.out.println(tigger.getUsername() + " password: " + tigger.getPassword());
    }
}
```

```java
// SecurityConfig.class
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers("/", "/hello").permitAll()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .and()
            .httpBasic();
    }

    @Bean
    public PasswordEncoder passwordEncoder() { // password encoding를 해주는 메서드
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }
}
```

## 스프링 REST 클라이언트 1부: RestTemplate과 WebClient

RestTemplate 

- Blocking I/O 기반의 Synchronous API (동기)
- RestTemplateAutoConfiguration

WebClient

- Non-Blocking I/O 기반의 Asynchronous API (비동기)
- WebClientAutoConfiguration

## 스프링 REST 클라이언트 2부: 커스터마이징

WebClient

- 커스터마이징

  ```java
  @SpringBootApplication
  public class Application {
  
      public static void main(String[] args) {
          SpringApplication.run(Application.class, args);
      }
  
      @Bean
      public WebClientCustomizer webClientCustomizer() {
          return new WebClientCustomizer() {
              @Override
              public void customize(WebClient.Builder WebClientBuilder) {
                  WebClientBuilder.baseUrl("http://localhost:8080");
              }
          };
      }
  }
  ```

RestTemplate

- 커스터마이징

  ```java
  @SpringBootApplication
  public class Application {
  
      public static void main(String[] args) {
          SpringApplication.run(Application.class, args);
      }
  
      @Bean
      public RestTemplateCustomizer restTemplateCustomizer() {
          return new RestTemplateCustomizer() {
              @Override
              public void customize(RestTemplate restTemplate) {
                  restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory());
              }
          };
      }
  }
  ```

## 스프링 부트 Actuator 1부: 소개

gradle 의존성 추가

```
implementation 'org.springframework.boot:spring-boot-starter-actuator'
```

자세한 것은 [여기](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready) 참조

## 스프링 부트 Actuator 2부: JMX와 HTTP

JConsole 사용하기

- 터미널에 jconsole 입력

VisualVM 사용하기

- 다음에 알아보자...

HTTP 사용하기

- /actuator
- health와 info를 제외한 대부분의 Endpoint가 기본적으로 비공개 상태
- 공개 옵션 조정
  - management.endpoints.web.exposure.include=*
  - management.endpoints.web.exposure.exclude=env,beans

## 스프링 부트 Actuator 3부: Spring-Boot-Admin

[여기](https://github.com/codecentric/spring-boot-admin) 참조

gradle 의존성 추가

어드민 서버 설정

```
implementation group: 'de.codecentric', name: 'spring-boot-admin-starter-server', version: '2.2.3'
```

@EnableAdminServer (Application.class에 추가)

클라이언트 서버 설정

```
implementation group: 'de.codecentric', name: 'spring-boot-admin-starter-client', version: '2.2.3'
```

application.properties

```
management.endpoints.web.exposure.include=*
#어드민 서버 port
spring.boot.admin.client.url=http://localhost:8080
#클라이언트 서버 port
server.port=18080
```

http://localhost:8080로 가면 admin페이지가 나온다.